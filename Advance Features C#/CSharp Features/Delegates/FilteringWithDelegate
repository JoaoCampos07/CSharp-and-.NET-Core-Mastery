namespace BM.App.Retail.Customer.Application.Accounts.Queries
{
    using BM.App.Retail.Customer.Application.Extensions;
    using BM.App.Retail.Customer.Application.Mappers.Account;
    using BM.App.Retail.Customer.Application.Rest.AccountResourceProxy;
    using BM.App.Retail.Customer.Application.Rest.AccountResourceProxy.Models;
    using BM.App.Retail.Customer.Domain.Accounts.Models;
    using BM.App.Retail.Customer.Domain.Accounts.QueryParams;
    using BM.Infrastructure.Common.Validation;
    using BM.Infrastructure.CQRS.Common.Queries;
    using BM.Security.Signing.Abstractions;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    public class GetAccountsByProcessQuery : IQuery<IGetAccountsByProcessQueryParams, List<AccountResponse>>
    {
        // According to some process, we make some filtering 
        // In this case filter for the process MortgageInsuranceTransactionHistory
        // means Only normal Accounts with restrain number of relationships etc...
        private readonly Dictionary<ProcessName, Func<Account, bool>> _processes
            = new Dictionary<ProcessName, Func<Account, bool>>
            {
                { ProcessName.MortgageInsuranceTransactionHistory, TransactionHistoryFilter }
            };

        private static readonly string[] AcceptableRelations = { "SOW", "JOF", "JOO" };

        private readonly IBMDomainAccountsResourceProxy domainAccountsProxy;
        private readonly IIntegratedSigner integratedSigner;

        public GetAccountsByProcessQuery(
            IBMDomainAccountsResourceProxy domainAccountsProxy,
            IIntegratedSigner integratedSigner)
        {
            this.domainAccountsProxy = domainAccountsProxy;
            this.integratedSigner = integratedSigner;
        }

        public async Task<IQueryResult<List<AccountResponse>>> GetResultAsync(IGetAccountsByProcessQueryParams queryParams)
        {
            (var accounts, var errorResult) = await GetAccounts(queryParams);
            if (errorResult != null)
            {
                return QueryResult<List<AccountResponse>>.QueryFailed(errorResult);
            }

            if (!_processes.TryGetValue(queryParams.Process, out var filter))
            {
                return QueryResult<List<AccountResponse>>.QueryFailed(InvalidProcessName());
            }
            
            // The fileter is a pointer to function, a function that it will filter accordingly to the queryParam choosen 
            // by the client of the API
            var filteredAccounts = accounts.Where(filter)
                .OrderByDescending(x => x.AccountDetails.IsDefaultAccount);

            return QueryResult<List<AccountResponse>>.QuerySucceeded(
                    filteredAccounts.ToAccountsResponse(integratedSigner));
        }

        private async Task<(IList<Account>, ErrorResult)> GetAccounts(IGetAccountsByProcessQueryParams queryParams)
        {
            var accounts = await domainAccountsProxy.V2AccountsMillecodeByMillecodeGetWithHttpMessagesAsync(
                queryParams.Millecode,
                queryParams.Cif,
                includeDefaultAccount: false);

            if (!accounts.Response.IsSuccessStatusCode)
            {
                return (null, UnableToObtainAccounts());
            }

            return (accounts.Body, null);
        }

        private static ErrorResult UnableToObtainAccounts()
            => new ErrorResult(
                "UNABLE_TO_OBTAIN_TRANSFERS",
                "UNABLE_TO_OBTAIN_TRANSFERS",
                null,
                System.Net.HttpStatusCode.BadRequest,
                "UNABLE_TO_OBTAIN_TRANSFERS");

        private static ErrorResult InvalidProcessName()
            => new ErrorResult(
                "INVALID_OR_MISSING_PROCESS_NAME",
                "INVALID_OR_MISSING_PROCESS_NAME",
                null,
                System.Net.HttpStatusCode.BadRequest,
                "INVALID_OR_MISSING_PROCESS_NAME");

        private static bool TransactionHistoryFilter(Account a) =>
            a.IsCurrentAccount()
            && a.IsAcceptableRelationship(AcceptableRelations)
            && !a.IsJuniorAccount()
            && !a.IsInvisibleProduct();

    }
}
